import jsPDF from 'jspdf';
import autoTable from 'jspdf-autotable';

const normalizeAmount = (value) => {
  if (value === null || value === undefined) {
    return null;
  }

  if (typeof value === 'number') {
    return Number.isNaN(value) ? null : value;
  }

  if (typeof value === 'string') {
    const cleaned = value.replace(/[^0-9.-]/g, '');
    if (!cleaned.trim()) {
      return null;
    }
    const parsed = parseFloat(cleaned);
    return Number.isNaN(parsed) ? null : parsed;
  }

  return null;
};

const formatCurrency = (value) => {
  const amount = normalizeAmount(value);
  if (amount === null) {
    return '—';
  }
  return `PHP ${Math.abs(amount).toLocaleString('en-PH', {
    minimumFractionDigits: 2,
    maximumFractionDigits: 2,
  })}`;
};

const formatDate = (value) => {
  if (!value) return '—';
  try {
    return new Intl.DateTimeFormat('en-PH', {
      year: 'numeric',
      month: 'short',
      day: '2-digit',
    }).format(new Date(value));
  } catch (error) {
    return value;
  }
};

export const generateTransactionManagementPDF = ({
  filters = {},
  transactions = [],
  stats = {},
  generatedBy = 'System',
  reportTitle = 'Transaction Management Report',
}) => {
  // Use explicit A4 portrait for consistent sizing
  const doc = new jsPDF({ unit: 'mm', format: 'a4', orientation: 'portrait' });

  const pageWidth = doc.internal.pageSize.getWidth();
  const margin = 14;
  const centerX = pageWidth / 2;

  const addHeader = () => {
    doc.setFont('helvetica', 'bold');
    doc.setFontSize(16);
    doc.text(reportTitle, centerX, 18, { align: 'center' });

    doc.setFont('helvetica', 'normal');
    doc.setFontSize(11);
    doc.text(`Generated on: ${formatDate(new Date().toISOString())}`, centerX, 26, { align: 'center' });
    doc.text(`Generated by: ${generatedBy}`, centerX, 32, { align: 'center' });
  };

  const addFilters = () => {
    const filterEntries = Object.entries(filters)
      .filter(([, value]) => value !== undefined && value !== null && value !== '')
      .map(([key, value]) => `${key}: ${value}`);

    if (filterEntries.length === 0) return;

    doc.setFontSize(11);
    doc.text('Applied Filters:', margin, 40);
    doc.setFontSize(10);

    const chunkSize = 3;
    filterEntries.forEach((entry, index) => {
      const row = Math.floor(index / chunkSize);
      const col = index % chunkSize;
      const x = margin + col * 60;
      const y = 46 + row * 6;
      doc.text(`• ${entry}`, x, y);
    });
  };

  const addSummary = () => {
    const summaryStartY = 60;
    doc.setFontSize(11);
    doc.setFont('helvetica', 'bold');
    doc.text('Summary Statistics:', margin, summaryStartY);

    doc.setFont('helvetica', 'normal');
    doc.setFontSize(10);

    const summaryData = [
      ['Total Transactions', transactions.length.toString()],
      ['Total Collections', formatCurrency(stats.totalCollections || 0)],
      ['Total Disbursements', formatCurrency(stats.totalDisbursements || 0)],
      ['Net Balance', formatCurrency(stats.netBalance || 0)],
      ['Average Transaction', formatCurrency(stats.averageTransactionValue || 0)],
      ['Collection Rate', `${(stats.collectionRate || 0).toFixed(1)}%`],
    ];

    autoTable(doc, {
      head: [['Metric', 'Value']],
      body: summaryData,
      startY: summaryStartY + 6,
      margin: margin,
      theme: 'grid',
      headerStyles: {
        fillColor: [0, 0, 0],
        textColor: [255, 255, 255],
        fontStyle: 'bold',
        fontSize: 10,
        halign: 'left',
      },
      bodyStyles: {
        fontSize: 9,
        textColor: [0, 0, 0],
      },
      alternateRowStyles: {
        fillColor: [250, 250, 250],
      },
      columnStyles: {
        0: { halign: 'left', cellWidth: 50 },
        1: { halign: 'right', cellWidth: 40 },
      },
      didDrawPage: () => {},
    });
  };

  const addTransactionsTable = () => {
    const tableData = transactions.map((tx) => [
      `#${tx.id}`,
      tx.type || 'Unknown',
      formatCurrency(tx.amount),
      tx.recipient || 'N/A',
      (tx.creator?.name || tx.user?.name || 'N/A') + '\n(' + (tx.creator?.role || tx.user?.role || 'N/A') + ')',
      formatDate(tx.created_at),
    ]);

    // Get the current Y position after summary table
    const startY = doc.lastAutoTable ? doc.lastAutoTable.finalY + 8 : 70;

    // Make the table fill the space: compute dynamic column widths to fit usable width
    const usableWidth = pageWidth - margin * 2;
    // Relative distribution [ID, Type, Amount, Recipient/Payer, Created By, Date]
    const dist = [0.08, 0.12, 0.15, 0.38, 0.15, 0.12]; // sums to 1

    autoTable(doc, {
      head: [['ID', 'Type', 'Amount', 'Recipient/Payer', 'Created By', 'Date']],
      body: tableData,
      startY: startY,
      margin: { left: margin, right: margin },
      theme: 'grid',
      headerStyles: {
        fillColor: [0, 0, 0],
        textColor: [255, 255, 255],
        fontStyle: 'bold',
        fontSize: 10,
        halign: 'center',
      },
      bodyStyles: {
        fontSize: 9,
        textColor: [0, 0, 0],
      },
      alternateRowStyles: {
        fillColor: [250, 250, 250],
      },
      styles: {
        overflow: 'linebreak',
        cellPadding: 2,
      },
      tableWidth: 'auto',
      columnStyles: {
        0: { halign: 'center', cellWidth: usableWidth * dist[0] },
        1: { halign: 'center', cellWidth: usableWidth * dist[1] },
        2: { halign: 'right',  cellWidth: usableWidth * dist[2] },
        3: { halign: 'left',   cellWidth: usableWidth * dist[3] },
        4: { halign: 'left',   cellWidth: usableWidth * dist[4] },
        5: { halign: 'center', cellWidth: usableWidth * dist[5] },
      },
      didDrawPage: (data) => {
        // Footer
        const pageSize = doc.internal.pageSize;
        const pageHeight = pageSize.getHeight();
        const pageWidth = pageSize.getWidth();
        doc.setFontSize(9);
        doc.setTextColor(128);
        doc.text(
          `Page ${data.pageNumber} of ${doc.internal.pages.length - 1}`,
          pageWidth / 2,
          pageHeight - 10,
          { align: 'center' }
        );
      },
    });
  };

  // Build PDF
  addHeader();
  addFilters();
  addSummary();
  addTransactionsTable();

  // Return blob for preview/download
  const filename = `${reportTitle.replace(/\s+/g, '_').toLowerCase()}_${new Date().toISOString().split('T')[0]}.pdf`;
  const blob = doc.output('blob');
  return { blob, filename };
};
